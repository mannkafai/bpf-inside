# 使用libbpf库编写BPF程序

## 1 libbpf 简介

libbpf是一个基于C的库，包含一个BPF加载器，将已编译的BPF目标文件加载到linux内核中。libbpf负责加载(loading)、验证(verifying)和附加(attaching) BPF程序到各种内核挂钩中，让开发者只关注BPF程序的正确性和性能。

## 2 minimal示例

我们通过 `minimal` 示例来分析使用libbpf库编写的步骤，及加载BPF的过程。正如其名， `minimal` 是一个最小的BPF应用程序示例，它不使用或不需要BPF CO-RE，可以在比较旧的内核上运行。 `minimal`程序通过安装内核追踪点程序，每秒触发一次，BPF程序通过 `bpf_printk` BPF helper函数进行交互，我们使用 `root`(或者`sudo`) 读取 `/sys/kernel/debug/tracing/trace_pipe` 文件查看输出内容。

编译及运行过程如下：

```bash
$ cd src
$ make minimal
$ sudo ./bin/minimal
$ sudo cat /sys/kernel/debug/tracing/trace_pipe
         minimal-163968  [005] d..31 93003.877430: bpf_trace_printk: BPF triggered from PID 163968.
         minimal-163968  [005] d..31 93003.877441: bpf_trace_printk: BPF triggered from PID 163968.
```

`src/`目前包含了我们生成`minimal`程序所需的源码文件，内容如下：

```bash
$ tree 
.
├── bin
│   └── minimal
├── CMakeLists.txt
├── Makefile
├── minimal.bpf.c
└── minimal.c

1 directory, 5 files
```

`Makefile`和`CMakeLists.txt`定义了编译BPF程序的构建规则。文件命名约定如下：
- `<app>.bpf.c`是在内核上下文中执行的BPF C代码；
- `<app>.c`是用户空间C代码，负责加载BPF程序，并在程序生命周期中与其交互；
- 可选的`<app.h>`定义了BPF程序和用户空间程序共享的通用类型定义。

`minimal`程序包括`minimal.bpf.c`和`minimal.c`代码文件。

### 2.1 BPF程序

BPF程序文件([minimal.bpf.c](https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/minimal.bpf.c))完整代码如下：

```C
// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
/* Copyright (c) 2020 Facebook */
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>

char LICENSE[] SEC("license") = "Dual BSD/GPL";

int my_pid = 0;

SEC("tp/syscalls/sys_enter_write")
int handle_tp(void *ctx)
{
    int pid = bpf_get_current_pid_tgid() >> 32;
    if (pid != my_pid)
        return 0;
    bpf_printk("BPF triggered from PID %d.\n", pid);
    return 0;
}
```

`<linux/bpf.h>`头文件包含了内核侧BPF API所需的BPF相关的基本类型和常量(如：BPF helper 函数标记)。 `<bpf/bpf_helpers.h>` 由`libbpf`提供，依赖于`<linux/bpf.h>`头文件，提供了常用的宏定义、常量、BPF helper定义，几乎每个BPF程序都包含该文件。

`LICENSE`变量定义了BPF代码的许可，代码许可是内核强制需要的。一些BPF功能对于非GPL兼容代码是不可用的。 `SEC()` 在 `<bpf/bpf_helpers.h>` 中定义，用来将变量或函数放到指定的`section`中。`libbpf`提供了`SEC("license")`和其他的名称约定。

接下来是BPF的全局变量，`int my_pid = 0;`定义了一个全局变量、BPF代码可以读取和更新该变量，就像用户空间C代码对全局变量的操作一样。使用全局变量来维护BPF程序的状态非常方便且高效。此外，从用户空间程序可以读取和写入此类全局变量。

`SEC("tp/syscalls/sys_enter_write") int handle_tp(void *ctx) { ... }` 定义了加载到内核中BPF程序代码。这段代码表示一个普通的C函数，并通过`SEC()`宏指定到特定`section`，节名称定义了`libbpf`创建BPF程序的类型及将其附加到内核中方式。在本例中，我们定义了一个追踪点(tracepoint)BPF程序，任何用户空间程序的调用`write()`系统调用时都会调用该程序。

现在让我们看看`handle_tp`函数在做什么：

```c
    int pid = bpf_get_current_pid_tgid() >> 32;
    if (pid != my_pid)
        return 0;
```

这部分代码获取`PID`(内核术语中`TGID`)中的 `bpf_get_current_pid_tgid()` 返回值高32位，然后检查触发 `write()` 系统调用的程序是否是我们的 `minimal` 程序。`my_pid`是个全局变量，通过用户空间程序初始化为`minimal`程序的实际PID。

```c
    bpf_printk("BPF triggered from PID %d.\n", pid);
```

BPF版`prinf`函数，它将格式化的字符串发送到 `/sys/kernel/debug/tracing/trace_pipe` 特殊文件中，我们可以通过控制台查看其内容(在root或`sudo`下运行)：

```bash
$ sudo cat /sys/kernel/debug/tracing/trace_pipe
         minimal-163968  [005] d..31 93003.877430: bpf_trace_printk: BPF triggered from PID 163968.
         minimal-163968  [005] d..31 93003.877441: bpf_trace_printk: BPF triggered from PID 163968.
```

这就是`minimal`程序BPF侧的内容。我们可以向`handle_tp`函数中根据需要添加扩展代码。


### 2.2 用户空间程序

接下来，我们来分析用户空间程序([minimal.c](https://github.com/libbpf/libbpf-bootstrap/blob/master/examples/c/minimal.c))，我们跳过一些相当明显的代码。

#### 骨架文件

```C
#include "minimal.skel.h"
```

该文件包含了`minimal.bpf.c`文件中的BPF代码生成的BPF骨架文件，是`minimal.bpf.c`的高层级结构映射。它由`bpftool`在Makefile步骤中自动生成的。

骨架头文件将编译后的BPF目标文件内容嵌入其中，来简化BPF代码部署流程，用户空间程序无需其他额外的二进制文件，只需要包含头文件即可。`BPF`骨架文件基于`libbpf`构建的，内核对此一无所知。对于BPF开发人员来说是个巨大的改善。

BPF骨架文件在`make`编译程序后，生成在 `src/.output/<app>.skel.h` 。我们简单看下反映 `minimal.bpf.c` 的骨架文件：

```C
/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */

/* THIS FILE IS AUTOGENERATED BY BPFTOOL! */
#ifndef __MINIMAL_BPF_SKEL_H__
#define __MINIMAL_BPF_SKEL_H__

#include <errno.h>
#include <stdlib.h>
#include <bpf/libbpf.h>

struct minimal_bpf {
	struct bpf_object_skeleton *skeleton;
	struct bpf_object *obj;
	struct {
		struct bpf_map *bss;
		struct bpf_map *rodata;
	} maps;
	struct {
		struct bpf_program *handle_tp;
	} progs;
	struct {
		struct bpf_link *handle_tp;
	} links;
	struct minimal_bpf__bss {
		int my_pid;
	} *bss;

#ifdef __cplusplus
	...
#endif /* __cplusplus */
};

static void minimal_bpf__destroy(struct minimal_bpf *obj) { ... }
static inline struct minimal_bpf *minimal_bpf__open_opts(const struct bpf_object_open_opts *opts) { ... }
static inline struct minimal_bpf *minimal_bpf__open(void) { ... }
static inline int minimal_bpf__load(struct minimal_bpf *obj) { ... }
static inline struct minimal_bpf * minimal_bpf__open_and_load(void) { ... }
static inline int minimal_bpf__attach(struct minimal_bpf *obj) { ... }
static inline void minimal_bpf__detach(struct minimal_bpf *obj) { ... }
static inline int minimal_bpf__create_skeleton(struct minimal_bpf *obj) { ... }
static inline const void *minimal_bpf__elf_bytes(size_t *sz) { ... }

#ifdef __cplusplus
	...
#endif /* __cplusplus */

__attribute__((unused)) static void
minimal_bpf__assert(struct minimal_bpf *s __attribute__((unused))) { ... }

#endif /* __MINIMAL_BPF_SKEL_H__ */
```

可以看到，`minimal_bpf`骨架主要字段说明如下：

* `bpf_object_skeleton *skeleton` : `libbpf`API使用的骨架信息；
* `bpf_object *obj`：传递给`libbpf`API函数功能使用的结构；
* `maps`,`progs`,`links`：定义了直接访问BPF代码中定义的BPF映射(MAP)和程序；可以直接传递到libbpf API中对映射、程序、链接进行额外的操作。
  
骨架根据情况生成`bss`,`rodata`，`data`字段，允许用户空间直接访问BPF全局变量。如，示例程序中的`my_pid`变量对应`bss->my_pid`字段。

#### 用户空间程序

现在我们来看看用户空间的`main()`函数做了什么：

```C
int main(int argc, char **argv)
{
	struct minimal_bpf *skel;
	int err;

	/* Set up libbpf errors and debug info callback */
	libbpf_set_print(libbpf_print_fn);

```

`libbpf_set_print` 函数设置了`libbpf`日志函数的回调函数，在开发过程中我们可以捕获所有的libbpf调试日志。在本示例中，我们将所有的内容进行标准输出。

```C
	/* Open BPF application */
	skel = minimal_bpf__open();
	if (!skel) {
		fprintf(stderr, "Failed to open BPF skeleton\n");
		return 1;
	}
```

现在，调用 `minimal_bpf__open` 创建自动生成的BPF骨架。

```C
	/* ensure BPF program only handles write() syscalls from our process */
	skel->bss->my_pid = getpid();
```

现在，我们将PID传递到BPF代码中，BPF程序过滤掉不相关程序的`write()`系统调用。`my_pid`通过内存映射区域直接设置BPF全局变量。

```C
	/* Load & verify BPF programs */
	err = minimal_bpf__load(skel);
	if (err) {
		fprintf(stderr, "Failed to load and verify BPF skeleton\n");
		goto cleanup;
	}

```

现在，我们 调用 `minimal_bpf__load` 加载BPF程序到内核中，BPF验证器对BPF程序进行验证检查。在验证通过后，我们可以附加到任何需要的BPF挂钩中。

```C
	/* Attach tracepoint handler */
	err = minimal_bpf__attach(skel);
	if (err) {
		fprintf(stderr, "Failed to attach BPF skeleton\n");
		goto cleanup;
	}
	printf("Successfully started! Please run `sudo cat /sys/kernel/debug/tracing/trace_pipe` "
	       "to see output of the BPF programs.\n");
```

现在，在调用 `minimal_bpf__attach` 后，我们终于可以将`handle_tp` BPF程序附加到相应的内核追踪点。此时，通过`write()`系统调用激活BPF程序，内核将执行我们自定义的BPF代码。

```C
	for (;;) {
		/* trigger our BPF program */
		fprintf(stderr, ".");
		sleep(1);
	}
```

在无限循环里周期性(每秒一次)调用`fprintf`函数生成`write()`系统调用。这样，我们就可以"监视"内核内部执行`handle_tp`的状态。同时，无限循环确保`handle_tp`BPF程序保持附加在内核中，直到用户杀死该进程（如：通过`Ctrl-C`）。

```C
cleanup:
	minimal_bpf__destroy(skel);
	return -err;
}
```

在前面的任何步骤出错或退出程序时，`minimal_bpf__destroy`将清理所有用户空间和内核的资源。

`minimal`的用户空间程序就是这样，使用BPF骨架将这一切变得非常简单。

### 2.3 程序编译步骤

我们通过`make minimal V=1`查看`minimal`程序的编译过程，如下：

```bash
clang -g -O2 -target bpf -D__TARGET_ARCH_x86                  \
             -I.output -I../libbpf/include/uapi -I../vmlinux/x86/ -I/<project>/blazesym/include -idirafter /usr/lib/llvm-14/lib/clang/14.0.0/include -idirafter /usr/local/include -idirafter /usr/include/x86_64-linux-gnu -idirafter /usr/include                 \
             -c minimal.bpf.c -o .output/minimal.tmp.bpf.o
```

首先，我们编译 `minimal.bpf.c` 文件。该文件通过`Clang`进行编译，`-g`选项生成BTF信息; `-O2`选项对BPF程序进行优化; `-target bpf` 指定编译目标为bpf格式;`-D__TARGET_ARCH_<ARCH>` 定义了 `bpf_tracing.h` 处理低级 `struct pt_regs` 时需要宏; `<ARCH>`通过获取主机的系统架构得到，目前我们在运行在x86架构下。

```bash
/<project>/src/.output/bpftool/bootstrap/bpftool gen object .output/minimal.bpf.o .output/minimal.tmp.bpf.o
```
接下来，我们生成只包含目标信息的`.o`文件，通过`-g`选项编译时，Clang编译的文件包含DWARF调试信息，而这部分信息我们不会用到。我们通过`bpftool gen object`来生成`.bpf.o`文件，也可以通`llvm-strip`来删除DWARF信息来生成该文件。

```bash
/<project>/src/.output/bpftool/bootstrap/bpftool gen skeleton .output/minimal.bpf.o > .output/minimal.skel.h
```

现在，我们已经生成了`bpf.o`文件，通过`bpftool gen skeleton`命令来生成BPF骨架文件（ `.skel.h` ）。

```bash
cc -g -Wall -I.output -I../libbpf/include/uapi -I../vmlinux/x86/ -I/<project>/blazesym/include -c minimal.c -o .output/minimal.o
```

接下来，编译用户程序，从`.c`文件编译成`.o`文件。

```bash
cc -g -Wall .output/minimal.o /<project>/src/.output/libbpf.a   -lrt -ldl -lpthread -lm -lelf -lz -o bin/minimal
```

最后，使用用户空间`.o`文件和`libbpf.a`静态库文件生成最终的二进制文件，`-lelf`和`-lz`是libbpf的依赖项。

就这样，进行以上几个步骤后，我们最终得到了一个用户空间的二进制文件，通过BFP骨架嵌入编译后的BPF代码，静态连接libbpf库，不依赖系统层面的libbpf库。当然，我们也可将libbpf编译成动态。

## 3 BPF程序的生命周期

一个BPF应用程序由一个或多个BPF程序（协作或完全独立）、BPF映射和全局变量组成。全局变量在所有BPF程序之间共享，这使得它们能够在一组公共数据上进行合作。libbpf提供了用户空间程序可用于管理BPF应用程序不同阶段生命周期的API。

下面简要概述了BPF生命周期中的每个阶段：

* 打开阶段(Open phase)：在此阶段，libbpf解析BPF目标文件，发现BPF映射、BPF程序和全局变量。打开BPF应用程序后，用户空间应用程序可以在创建和加载所有实体之前进行其他调整（如：有必要时设置BPF程序类型；为全局变量预先设置初始值等）。
* 加载阶段(Load phase)：在加载阶段，libbpf创建BPF映射、解析各种重定位、验证BPF程序并将其加载到内核中。此时，libbpf验证了BPF应用程序的所有部分，并将BPF程序加载到内核中，但尚未执行任何BPF程序。加载阶段之后，可以设置初始BPF映射状态，与BPF程序代码间没有执行竞争。
* 附加阶段(Attachment phase)：在这个阶段，libbpf将BPF程序附加到各种BPF挂钩点（例如，tracepoints、kprobes、cgroup挂钩、网络数据包处理管道等）。在此阶段，BPF程序执行有用的工作，如：处理数据包、更新从用户空间读取的BPF映射和全局变量。
* 拆卸阶段(Tear down phase)：在拆卸阶段，libbpf从内核中分离和卸载BPF程序。销毁BPF映射，释放BPF应用程序使用的所有资源。

生成的BPF骨架提供了与BPF生命周期相对应的自定义函数，每个函数都以特定的对象名称为前缀：
* `<name>__open()` – 创建并打开BPF应用程序;
* `<name>__load()` – 实例化、加载和验证 BPF 应用程序;
* `<name>__attach()` – 附加所有可自动附加的BPF程序（这是可选的，我们可以直接使用libbpf API进行更细致的控制）;
* `<name>__destroy()` – 分离所有BPF程序并释放所有使用的资源。

### 3.1 打开阶段（Open phase）

打开阶段对应的函数为`minimal_bpf__open`, 实现如下：

```c
static inline struct minimal_bpf *
minimal_bpf__open(void)
{
	return minimal_bpf__open_opts(NULL);
}

static inline struct minimal_bpf *
minimal_bpf__open_opts(const struct bpf_object_open_opts *opts)
{
	struct minimal_bpf *obj;
	int err;
	obj = (struct minimal_bpf *)calloc(1, sizeof(*obj));
	if (!obj) {
		errno = ENOMEM;
		return NULL;
	}
	err = minimal_bpf__create_skeleton(obj);
	if (err) goto err_out;
	err = bpf_object__open_skeleton(obj->skeleton, opts);
	if (err) goto err_out;
	return obj;
err_out:
	minimal_bpf__destroy(obj);
	errno = -err;
	return NULL;
}
```

可以看到，`minimal_bpf__open`直接调用 `minimal_bpf__open_opts` 函数。后者在分配`minimal_bpf`内存资源后，调用 `minimal_bpf__create_skeleton` 创建骨架信息，最后调用 `bpf_object__open_skeleton` 函数打开骨架。

`minimal_bpf__create_skeleton` 函数创建 `minimal` 所需的MAP和程序信息，设置BPF程序的二进制内容，主要代码如下：

```C
static inline int
minimal_bpf__create_skeleton(struct minimal_bpf *obj)
{
	struct bpf_object_skeleton *s;
	int err;
	s = (struct bpf_object_skeleton *)calloc(1, sizeof(*s));
	...
	s->sz = sizeof(*s);
	s->name = "minimal_bpf";
	s->obj = &obj->obj;
	/* maps */
	s->map_cnt = 2;
	s->map_skel_sz = sizeof(*s->maps);
	s->maps = (struct bpf_map_skeleton *)calloc(s->map_cnt, s->map_skel_sz);
	...
	s->maps[0].name = "minimal_.bss";
	s->maps[0].map = &obj->maps.bss;
	s->maps[0].mmaped = (void **)&obj->bss;

	s->maps[1].name = "minimal_.rodata";
	s->maps[1].map = &obj->maps.rodata;

	/* programs */
	s->prog_cnt = 1;
	s->prog_skel_sz = sizeof(*s->progs);
	s->progs = (struct bpf_prog_skeleton *)calloc(s->prog_cnt, s->prog_skel_sz);
	...
	s->progs[0].name = "handle_tp";
	s->progs[0].prog = &obj->progs.handle_tp;
	s->progs[0].link = &obj->links.handle_tp;

	s->data = (void *)minimal_bpf__elf_bytes(&s->data_sz);

	obj->skeleton = s;
	return 0;
err:
	bpf_object__destroy_skeleton(s);
	return err;
}
```

`bpf_object__open_skeleton`函数在libbpf中实现，如下：

```C
int bpf_object__open_skeleton(struct bpf_object_skeleton *s, const struct bpf_object_open_opts *opts)
    -> obj = bpf_object__open_mem(s->data, s->data_sz, &skel_opts);
        -> bpf_object_open(NULL, obj_buf, obj_buf_sz, opts);
            -> obj = bpf_object__new(path, obj_buf, obj_buf_sz, obj_name);
                -> obj = calloc(1, sizeof(struct bpf_object) + strlen(path) + 1);
                -> obj->kern_version = get_kernel_version();
            -> bpf_object__elf_init(obj);
            -> bpf_object__check_endianness(obj);
            -> bpf_object__elf_collect(obj);
                --> bpf_object__init_license(obj, data->d_buf, data->d_size);
                --> bpf_object__init_kversion(obj, data->d_buf, data->d_size);
                --> bpf_object__add_programs(obj, data, name, idx);
                --> bpf_object__init_btf(obj, btf_data, btf_ext_data);
                    --> obj->btf = btf__new(btf_data->d_buf, btf_data->d_size);
                    --> obj->btf_ext = btf_ext__new(btf_ext_data->d_buf, btf_ext_data->d_size);
            -> bpf_object__collect_externs(obj);
            -> bpf_object_fixup_btf(obj);
            -> bpf_object__init_maps(obj, opts);
                --> bpf_object__init_user_btf_maps(obj, strict, pin_root_path);
                    --> bpf_object__init_user_btf_map(obj, sec, i, obj->efile.btf_maps_shndx, ...);
                        --> def = skip_mods_and_typedefs(obj->btf, var->type, NULL);
                        --> map = bpf_object__add_map(obj);
                        --> parse_btf_map_def(map->name, obj->btf, def, strict, &map_def, &inner_def);
                        --> fill_map_from_def(map, &map_def);
                        --> fill_map_from_def(map, &inner_def);
                        --> map_fill_btf_type_info(obj, map);
                --> bpf_object__init_global_data_maps(obj);
                    --> bpf_object__init_internal_map(obj, LIBBPF_MAP_DATA, ...);
                        --> map = bpf_object__add_map(obj); //BPF_MAP_TYPE_ARRAY
                        --> map_fill_btf_type_info(obj, map);
                        --> map->mmaped = mmap(NULL, mmap_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
                    --> bpf_object__init_internal_map(obj, LIBBPF_MAP_RODATA, ...);
                        --> map = bpf_object__add_map(obj); //BPF_MAP_TYPE_ARRAY
                        --> map_fill_btf_type_info(obj, map);
                        --> map->mmaped = mmap(NULL, mmap_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
                    --> bpf_object__init_internal_map(obj, LIBBPF_MAP_BSS, ...);
                        --> map = bpf_object__add_map(obj); //BPF_MAP_TYPE_ARRAY
                        --> map_fill_btf_type_info(obj, map);
                        --> map->mmaped = mmap(NULL, mmap_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
                --> bpf_object__init_kconfig_map(obj);
                    --> bpf_object__init_internal_map(obj, LIBBPF_MAP_KCONFIG, ...);
                        --> map = bpf_object__add_map(obj); //BPF_MAP_TYPE_ARRAY
                        --> map_fill_btf_type_info(obj, map);
                        --> map->mmaped = mmap(NULL, mmap_sz, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
                --> bpf_object_init_struct_ops(obj);
                    --> init_struct_ops_maps(obj, STRUCT_OPS_SEC, obj->efile.st_ops_shndx, ...);
                        --> map = bpf_object__add_map(obj); //BPF_MAP_TYPE_STRUCT_OPS
                    --> init_struct_ops_maps(obj, STRUCT_OPS_LINK_SEC, ...);
                        --> map = bpf_object__add_map(obj); //BPF_MAP_TYPE_STRUCT_OPS
            -> bpf_object_init_progs(obj, opts);
                --> prog->sec_def = find_sec_def(prog->sec_name);
                --> prog->type = prog->sec_def->prog_type;
                --> prog->expected_attach_type = prog->sec_def->expected_attach_type;
                --> prog->sec_def->prog_setup_fn(prog, prog->sec_def->cookie);
            -> bpf_object__collect_relos(obj);
                --> bpf_object__collect_st_ops_relos(obj, shdr, data);
                --> bpf_object__collect_map_relos(obj, shdr, data);
                --> bpf_object__collect_prog_relos(obj, shdr, data);
    -> *s->obj = obj;
    -> populate_skeleton_maps(obj, s->maps, s->map_cnt);
        --> *map = bpf_object__find_map_by_name(obj, name);
    -> populate_skeleton_progs(obj, s->progs, s->prog_cnt);
        --> *prog = bpf_object__find_program_by_name(obj, name);
```

`bpf_object__elf_init`函数用来检查ELF二进制文件是否有效BPF程序；

`bpf_object__check_endianness`函数用来检查大小端是否匹配；

`bpf_object__elf_collect`函数解析ELF文件的节信息(section)，根据节名称进行对应处理。节对应的处理方式如下：

|  节名称/可执行  |      类型     |     处理方式     |
|  :---         |    :----:    |            :--- |
|               |  SHT_SYMTAB  | obj->efile.symbols = data;   |
|license        |              | bpf_object__init_license(obj, ...);  |
|version        |              | bpf_object__init_kversion(obj, ...); |
|maps           |              | return -ENOTSUP; |
|.maps          |              | obj->efile.btf_maps_shndx = idx; |
|.BTF           | SHT_PROGBITS | btf_data = data; |
|.BTF.ext       | SHT_PROGBITS | btf_ext_data = data; |
|SHF_EXECINSTR  | SHT_PROGBITS | bpf_object__add_programs(obj, data, name, idx); |
|.data/.data.*  | SHT_PROGBITS | sec_desc->sec_type = SEC_DATA; |
|.rodata/.rodata.*  | SHT_PROGBITS | sec_desc->sec_type = SEC_RODATA; |
|.struct_ops    | SHT_PROGBITS | obj->efile.st_ops_data = data; |
|.struct_ops.link  | SHT_PROGBITS | obj->efile.st_ops_link_data = data; |
|.rel*[^rel]  | SHT_REL | sec_desc->sec_type = SEC_RELO; |
|.bss/.bss.*  | SHT_NOBITS | sec_desc->sec_type = SEC_BSS; |

[^rel]: ".rel.struct_ops"，".rel.struct_ops.link "，".rel.maps"这三个除外。

`bpf_object__add_programs`函数将ELF文件中可执行的代码段解析为程序；

`bpf_object__init_btf`函数解析`.BTF`和`.BTF.ext`信息；

`bpf_object__collect_externs`函数根据符号表解析外部符号。

`bpf_object_fixup_btf`函数修正BTF数据访问的偏移量和访问方式。

`bpf_object__init_maps`函数添加map信息，如：查找BTF map位置，添加全局数据map，kconfig信息map，struct_ops Map信息；

`bpf_object_init_progs`函数遍历所有的progs，确定每个prog的sec定义，设置prog的type和expected_attach_type，在sec设置了初始化时进行初始化。`prog`的sec根据名称进行匹配，支持用户自定义设置。libbpf默认支持100多种[section定义](https://github.com/libbpf/libbpf/blob/master/src/libbpf.c#L8657)，全部列表参见[官方文档](https://github.com/libbpf/libbpf/blob/master/docs/program_types.rst)。常用的有： `tracepoint`, `kprobe`, `kretprobe`, `kprobe.multi`, `kretprobe.multi`, `uprobe`, `uretprobe`, `usdt`, `ksyscall`, `kretsyscall`, `fentry`, `fexit`, `lsm`, `socket`, `perf_event`等。我们的`minimal`程序只有一个BPF程序(`handle_tp`)，`SEC`名称为`tp/syscalls/sys_enter_write`，我们没有添加自定义sec定义，libbpf中符合条件的定义为：

```C
#define SEC_DEF(sec_pfx, ptype, atype, flags, ...) {			    \
	.sec = (char *)sec_pfx,						    \
	.prog_type = BPF_PROG_TYPE_##ptype,				    \
	.expected_attach_type = atype,					    \
	.cookie = (long)(flags),					    \
	.prog_prepare_load_fn = libbpf_prepare_prog_load,		    \
	__VA_ARGS__							    \
}
	...
	SEC_DEF("tp+",			TRACEPOINT, 0, SEC_NONE, attach_tp),
```

`bpf_object__collect_relos`函数处理重定位信息，包括：`struct_ops`重定位、`map`重定位、`prog`重定位。

`populate_skeleton_maps`函数对 `minimal_bpf__create_skeleton` 中创建的map通过名称进行查找后关联。

`populate_skeleton_progs`函数对 `minimal_bpf__create_skeleton` 中创建的prog通过名称进行查找后关联。

这就是libbpf在打开阶段所有的工作。

我们可以通过`llvm-objdump`查看`minimal.bpf.o`所有的节信息、符号表和重定位信息，如下：

```bash
$ llvm-objdump-14  .output/minimal.bpf.o -x

.output/minimal.bpf.o:  file format elf64-bpf
architecture: bpfel
start address: 0x0000000000000000

Program Header:

Dynamic Section:

Sections:
Idx Name                            Size     VMA              Type
  0                                 00000000 0000000000000000 
  1 .strtab                         000000b0 0000000000000000 
  2 .symtab                         000000d8 0000000000000000 
  3 tp/syscalls/sys_enter_write     00000068 0000000000000000 TEXT
  4 license                         0000000d 0000000000000000 DATA
  5 .bss                            00000004 0000000000000000 BSS
  6 .rodata                         0000001c 0000000000000000 DATA
  7 .reltp/syscalls/sys_enter_write 00000020 0000000000000000 
  8 .BTF                            00000253 0000000000000000 
  9 .BTF.ext                        000000a0 0000000000000000 

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 minimal.bpf.c
0000000000000000 l    d  tp/syscalls/sys_enter_write    0000000000000000 tp/syscalls/sys_enter_write
0000000000000058 l       tp/syscalls/sys_enter_write    0000000000000000 LBB0_2
0000000000000000 l     O .rodata        000000000000001c handle_tp.____fmt
0000000000000000 l    d  .rodata        0000000000000000 .rodata
0000000000000000 g     F tp/syscalls/sys_enter_write    0000000000000068 handle_tp
0000000000000000 g     O .bss   0000000000000004 my_pid
0000000000000000 g     O license        000000000000000d LICENSE

RELOCATION RECORDS FOR [tp/syscalls/sys_enter_write]:
OFFSET           TYPE                     VALUE
0000000000000010 R_BPF_64_64              my_pid
0000000000000030 R_BPF_64_64              .rodata
```

### 3.2 加载阶段（Load phase）

加载阶段对应的函数为`minimal_bpf__load`, 实现如下：

```C
static inline int
minimal_bpf__load(struct minimal_bpf *obj)
{
	return bpf_object__load_skeleton(obj->skeleton);
}
```

`bpf_object__load_skeleton`函数在libbpf中实现，如下：

```C
int bpf_object__load_skeleton(struct bpf_object_skeleton *s)
    --> bpf_object__load(*s->obj);
        --> bpf_object_load(obj, 0, NULL);
            --> bpf_object__probe_loading(obj);
                --> bump_rlimit_memlock();
                --> bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, NULL, "GPL", insns, insn_cnt, NULL)
                --> bpf_prog_load(BPF_PROG_TYPE_TRACEPOINT, NULL, "GPL", insns, insn_cnt, NULL);
            --> bpf_object__load_vmlinux_btf(obj, false);
                --> obj->btf_vmlinux = btf__load_vmlinux_btf();
            --> bpf_object__resolve_externs(obj, obj->kconfig);
                --> bpf_object__read_kconfig_mem(obj, extra_kconfig, kcfg_data);
                --> bpf_object__read_kconfig_file(obj, kcfg_data);
                --> bpf_object__read_kallsyms_file(obj);
                --> bpf_object__resolve_ksyms_btf_id(obj);
            --> bpf_object__sanitize_and_load_btf(obj);
                --> btf_needs_sanitization(obj);
                --> bpf_object__sanitize_btf(obj, kern_btf);
                --> btf_load_into_kernel(kern_btf, obj->log_buf, obj->log_size, obj->log_level ? 1 : 0);
                    --> btf->fd = bpf_btf_load(raw_data, raw_size, &opts);
            --> bpf_object__sanitize_maps(obj);
            --> bpf_object__init_kern_struct_ops_maps(obj);
                --> bpf_map__init_kern_struct_ops(map, obj->btf, obj->btf_vmlinux);
                    --> find_struct_ops_kern_types(kern_btf, tname, ...);
            --> bpf_object__create_maps(obj);
                --> map_set_def_max_entries(map);
                --> bpf_object__create_map(obj, map, false);
                    --> map->fd = bpf_map_create(def->type, map_name, def->key_size, def->value_size, ...);
                --> bpf_object__populate_internal_map(obj, map); //bpf_map__is_internal(map)
                    --> bpf_map_update_elem(map->fd, &zero, map->mmaped, 0);
                    --> bpf_map_freeze(map->fd); //Freeze .rodata and .kconfig map as read-only from syscall side
                --> init_map_in_map_slots(obj, map);
                --> bpf_map__pin(map, NULL);
                    --> bpf_obj_pin(map->fd, map->pin_path)
            --> bpf_object__relocate(obj, obj->btf_custom_path ? : target_btf_path);
                --> bpf_object__relocate_core(obj, targ_btf_path);
                --> bpf_object__sort_relos(obj);
                --> bpf_object__relocate_calls(obj, prog);
                --> bpf_object__relocate_data(obj, prog);
            --> bpf_object__load_progs(obj, extra_log_level);
                --> bpf_object__sanitize_prog(obj, prog);
                --> bpf_object_load_prog(obj, prog, prog->insns, prog->insns_cnt, obj->license, obj->kern_version, &prog->fd);
                    --> prog->sec_def->prog_prepare_load_fn(prog, &load_attr, prog->sec_def->cookie); //prog_prepare_load_fn valid
                    --> bpf_prog_load(prog->type, prog_name, license, insns, insns_cnt, &load_attr);
                --> bpf_object__free_relocs(obj);
            --> bpf_object_init_prog_arrays(obj);
                --> init_prog_array_slots(obj, map);
                    --> bpf_map_update_elem(map->fd, &i, &fd, 0);
            --> bpf_object_prepare_struct_ops(obj);
                --> bpf_map_prepare_vdata(&obj->maps[i])
            --> btf__free(obj->btf_vmlinux);
    --> *mmaped = mmap(map->mmaped, mmap_sz, prot, MAP_SHARED | MAP_FIXED, map_fd, 0);
```

`bpf_object__load_skeleton` 在调用 `bpf_object__load` 后，对每个map进行mmap内存映射。

`bpf_object__probe_loading` 函数使用 `SOCKET_FILTER` 和`TRACEPOINT` 两种类型BPF程序验证内核是否支持BPF。

`bpf_object__load_vmlinux_btf` 函数在强制需要或检查需要BFT信息，调用 `btf__load_vmlinux_btf` 加载btf信息，加载顺序如下：

```text
	"/sys/kernel/btf/vmlinux",
	"/boot/vmlinux-$(uname -r)",
	"/lib/modules/$(uname -r)/vmlinux-$(uname -r)",
	"/lib/modules/$(uname -r)/build/vmlinux",
	"/usr/lib/modules/$(uname -r)/kernel/vmlinux",
	"/usr/lib/debug/boot/vmlinux-$(uname -r)",
	"/usr/lib/debug/boot/vmlinux-$(uname -r).debug",
	"/usr/lib/debug/lib/modules/$(uname -r)/vmlinux",
```

`bpf_object__resolve_externs` 函数解析`kconfig`中名称对应内核符号及btf_id等信息。

`bpf_object__sanitize_and_load_btf` 将打开阶段获取的btf信息加载到内核中（内核支持BTF的情况下）。

`bpf_object__sanitize_maps` 根据内核信息修改map标记。

`bpf_object__init_kern_struct_ops_maps` 初始化 `struct_ops` 类型的map，在内核支持的情况下，通过BTF信息确定`struct_ops`每个字段定义。

`bpf_object__create_maps` 函数在内核中创建所有的map，初始化内部的map，设置`.rodata`和`.kconfig`两个map用户空间不能修改。可以根据需要pin到内核中。

`bpf_object__relocate` 函数处理重定位信息，在收集重定位信息后，逐程序确定确定指令和数据位置。

`bpf_object__load_progs` 函数在替换内核不支持的指令后，将prog加载到内核中。在所有progs加载完成后，释放重定位信息。

`bpf_object_init_prog_arrays` 函数在填充使用map的prog信息。

`bpf_object_prepare_struct_ops` 函数修改使用`struct_ops`的prog信息。

在上述过程都处理完成后，调用`btf__free`释放`btf_vmlinux`。

这就是整个加载阶段的全部工作。

### 3.3 附加阶段（Attachment phase）

附加阶段对应的函数为`minimal_bpf__attach`, 实现如下：

```C
static inline int
minimal_bpf__attach(struct minimal_bpf *obj)
{
	return bpf_object__attach_skeleton(obj->skeleton);
}
```

`bpf_object__attach_skeleton` 函数在libbpf中实现，如下：

```C
int bpf_object__attach_skeleton(struct bpf_object_skeleton *s)
{
	int i, err;
	for (i = 0; i < s->prog_cnt; i++) {
		struct bpf_program *prog = *s->progs[i].prog;
		struct bpf_link **link = s->progs[i].link;
		if (!prog->autoload || !prog->autoattach)
			continue;
		/* auto-attaching not supported for this program */
		if (!prog->sec_def || !prog->sec_def->prog_attach_fn)
			continue;
		/* if user already set the link manually, don't attempt auto-attach */
		if (*link)
			continue;
		err = prog->sec_def->prog_attach_fn(prog, prog->sec_def->cookie, link);
		if (err) {
			pr_warn("prog '%s': failed to auto-attach: %d\n",
				bpf_program__name(prog), err);
			return libbpf_err(err);
		}
	}
	return 0;
}
```

`bpf_object__attach_skeleton` 所做的工作非常简单，调用 `prog->sec_def->prog_attach_fn` 函数附加程序到内核中。根据打开阶段确定的 `SEC_DEF("tp+", TRACEPOINT, 0, SEC_NONE, attach_tp)` , 该SEC名称约定格式为 `tp/<category>/<name>` 或 `tracepoint/<category>/<name>` ，意味着 `handle_tp` 程序挂载在 `syscalls/sys_enter_write` 事件下，附加函数为`attach_tp`。`attach_tp` 实现如下：

```C
static int attach_tp(const struct bpf_program *prog, long cookie, struct bpf_link **link)
    --> *link = bpf_program__attach_tracepoint(prog, tp_cat, tp_name);
        --> bpf_program__attach_tracepoint_opts(prog, tp_category, tp_name, NULL);
            --> pfd = perf_event_open_tracepoint(tp_category, tp_name);
                --> tp_id = determine_tracepoint_id(tp_category, tp_name);
                    --> snprintf(file, sizeof(file), "%s/events/%s/%s/id", tracefs_path(), tp_category, tp_name);
                    --> parse_uint_from_file(file, "%d\n")
                --> pfd = syscall(__NR_perf_event_open, &attr, -1, 0, -1, PERF_FLAG_FD_CLOEXEC);
            --> link = bpf_program__attach_perf_event_opts(prog, pfd, &pe_opts);
                --> link_fd = bpf_link_create(prog_fd, pfd, BPF_PERF_EVENT, &link_opts); //需要内核支持，不强制ioctl的情况下
                    --> fd = sys_bpf_fd(BPF_LINK_CREATE, &attr, attr_sz);
                --> ioctl(pfd, PERF_EVENT_IOC_SET_BPF, prog_fd); //ioctl模式，不使用BPF_LINK_CREATE方式
                --> ioctl(pfd, PERF_EVENT_IOC_ENABLE, prog_fd); 
```

如上，整个`bpf_program__attach_tracepoint` 可分为两个阶段：

* 第一个阶段创建性能分析事件(`perf event`)。 在确定`tracepoint`的ID（通过读取 `/sys/kernel/debug/tracing/events/<category>/<name>/id` 或 `/sys/kernel/tracing/events/<category>/<name>/id` 文件获取）后，通过 `perf_event_open` 系统调用创建 `perf event`。
* 第二个阶段`perf event`挂载BPF程序并开启。可以通过bpf系统调用( `BPF_LINK_CREATE` ) 或 `ioctl` 方式( `PERF_EVENT_IOC_SET_BPF` ) 两种方式挂载BFP程序。最后通过 `ioctl`方式( `PERF_EVENT_IOC_ENABLE` ) 开启事件。

### 3.4 拆卸阶段(Tear down phase)

拆卸阶段对应的函数为`minimal_bpf__destroy`, 实现如下：

```C
static void
minimal_bpf__destroy(struct minimal_bpf *obj)
{
	if (!obj)
		return;
	if (obj->skeleton)
		bpf_object__destroy_skeleton(obj->skeleton);
	free(obj);
}
```

`bpf_object__destroy_skeleton` 函数在libbpf中实现，如下：

```C
void bpf_object__destroy_skeleton(struct bpf_object_skeleton *s)
    --> bpf_object__detach_skeleton(s);
        --> bpf_link__destroy(*link);
            --> link->detach(link);
            --> free(link->pin_path);
            --> link->dealloc(link); / free(link);
    --> bpf_object__close(*s->obj);
        --> usdt_manager_free(obj->usdt_man);
        --> bpf_gen__free(obj->gen_loader);
        --> bpf_object__elf_finish(obj);
        --> bpf_object_unload(obj);
        --> btf__free(obj->btf);
        --> btf_ext__free(obj->btf_ext);
        --> bpf_map__destroy(&obj->maps[i]);
        --> zfree(&obj->btf_custom_path);
        --> zfree(&obj->kconfig);
        --> zfree(&obj->externs);
        --> zfree(&obj->maps);
        --> bpf_program__exit(&obj->programs[i]);
        --> zfree(&obj->programs);
        --> free(obj);
    --> free(s->maps);
    --> free(s->progs);
    --> free(s);
}
```

整个拆卸过程在卸载附加的BPF程序后，通过`close`操作关闭创建的fd和`free`释放分配的内存。

## 4 总结

本文借助`minimal`示例分析了使用libbpf开发BPF程序的过程，分析了libbpf管理BPF程序生命周期的全过程。我们在使用libbpf开发时，一般只需要关注BPF程序的`SEC`定义即可。借助libbpf我们可以很快速的开发BPF程序。

## 引用

[libbpf-bootstrap](https://github.com/libbpf/libbpf-bootstrap)
[libbpf_overview](https://libbpf.readthedocs.io/en/latest/libbpf_overview.html)
[使用libbpf-bootstrap构建BPF应用程序](https://nakryiko.com/posts/libbpf-bootstrap/)